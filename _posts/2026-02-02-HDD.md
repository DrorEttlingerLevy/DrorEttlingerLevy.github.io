---
title: 'בעיות I/O ואיך פתרתי אותן'
date: 2026-02-02
permalink: /posts/2026/02/HDD/
image: /images/blog/HDD.jpeg
preview: >
  הקוד רץ לאט ולא הבנתי למה כי ביצעתי אופטימזציה, אחרי מחקרון הבנתי שזה בגלל שעשיתי multiprocessing למרות שהדתא יושב על HDD
header:
  teaser: /blog/HDD.jpeg
---
עבדתי לאחרונה על שיפור זמני הרצה במחקר שלי, עם בערך 7 טרה דטה של סאונד ווידאו בעיבוד אותות. כל הדטה יושב על HDD מסיבות טכניות. בהתחלה הלכתי באופן די טבעי על multiprocessing גם בשלב הקריאה, מתוך מחשבה שזה יאיץ את התהליך. בפועל קיבלתי ריצות איטיות ולא יציבות, וה CPU בכלל לא היה מנוצל כמו שציפיתי.

כשישבתי להבין איפה הבעיה, התברר שזה לא החישוב אלא הדרך שבה קראתי את הדטה. בכונן HDD יש ראש קריאה מכני אחד. כשכמה תהליכים מנסים לקרוא קבצים שונים במקביל, הם לא “מחכים בתור” אלא גורמים לראש הדיסק לקפוץ פיזית הלוך ושוב בין אזורים שונים. הקפיצות האלה יוצרות seek time ו latency, והופכות את הקריאה לאיטית הרבה יותר מקריאה רציפה.

במבנה הראשון שלי, ה multiprocess יצר גישה אקראית ומפוזרת לדיסק, וזה גרם לדיסק לעבוד בצורה הכי לא יעילה שיש. הפתרון לא היה להוסיף עוד תהליכים אלא לשנות את הארכיטקטורה, עברתי למודל שבו יש תהליך אחד שאחראי על הקריאה מהדיסק בצורה רציפה, ורק אחרי שהדטה כבר בזיכרון אני מפעילה multiprocessing על החישוב.

ברגע שהפרדתי בין I O לחישוב זמני הריצה השתפרו מאוד. מה שלמדתי מהמחקרון הזה הוא לפני שמוסיפים parallelism, צריך להבין איך החומרה עובדת ואיפה הצוואר הבקבוק.🍾